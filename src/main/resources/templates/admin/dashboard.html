<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Renzzle 어드민 - 팩/문제 관리</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', system-ui, sans-serif;
      margin: 0;
      min-height: 100vh;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      color: #e8e8e8;
      padding: 1rem 1rem 1rem 200px;
    }
    .side-nav {
      position: fixed;
      left: 0;
      top: 0;
      width: 180px;
      height: 100vh;
      background: rgba(0,0,0,0.3);
      padding: 1rem;
      overflow-y: auto;
    }
    .side-nav h3 {
      margin: 0 0 1rem;
      font-size: 1rem;
      color: #4a9eff;
    }
    .side-nav a {
      display: block;
      padding: 0.6rem 0.8rem;
      margin-bottom: 0.4rem;
      background: rgba(255,255,255,0.08);
      border-radius: 8px;
      color: #e8e8e8;
      text-decoration: none;
      font-size: 0.9rem;
      transition: background 0.2s;
    }
    .side-nav a:hover {
      background: rgba(255,255,255,0.15);
    }
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5rem;
      padding-bottom: 1rem;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }
    .header h1 { margin: 0; font-size: 1.35rem; }
    .header .user-info { font-size: 0.9rem; color: #b0b0b0; margin-right: 1rem; }
    .btn {
      padding: 0.5rem 1rem;
      border: none;
      border-radius: 8px;
      background: rgba(255,255,255,0.15);
      color: #fff;
      cursor: pointer;
      font-size: 0.9rem;
      text-decoration: none;
    }
    .btn:hover { background: rgba(255,255,255,0.25); }
    .btn-primary { background: linear-gradient(90deg, #4a9eff, #357abd); }
    .btn-primary:hover { opacity: 0.95; }
    .section {
      max-width: 720px;
      margin-bottom: 2rem;
      padding: 1.5rem;
      background: rgba(255,255,255,0.06);
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.1);
    }
    .section h2 { margin: 0 0 1rem; font-size: 1.15rem; }
    label { display: block; margin-bottom: 0.35rem; font-size: 0.9rem; color: #b0b0b0; }
    input, select, textarea {
      width: 100%;
      padding: 0.6rem 0.8rem;
      margin-bottom: 0.9rem;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 8px;
      background: rgba(0,0,0,0.2);
      color: #fff;
      font-size: 0.95rem;
    }
    textarea { min-height: 80px; resize: vertical; }
    input::placeholder, textarea::placeholder { color: #666; }
    input:focus, select:focus, textarea:focus {
      outline: none;
      border-color: #4a9eff;
    }
    .row { display: flex; gap: 1rem; }
    .row > * { flex: 1; }
    .msg {
      margin-top: 0.5rem;
      padding: 0.5rem;
      border-radius: 8px;
      font-size: 0.9rem;
      display: none;
    }
    .msg.show { display: block; }
    .msg.success { background: rgba(40,167,69,0.2); color: #90ee90; }
    .msg.error { background: rgba(220,53,69,0.2); color: #f8a0a0; }
    .lang-block {
      padding: 1rem;
      margin-bottom: 1rem;
      background: rgba(0,0,0,0.2);
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.1);
    }
    .lang-block h4 { margin: 0 0 0.5rem; font-size: 0.95rem; }
    ul.pack-list { list-style: none; padding: 0; margin: 0; }
    ul.pack-list li {
      padding: 0.6rem 0.8rem;
      margin-bottom: 0.4rem;
      background: rgba(0,0,0,0.2);
      border-radius: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    ul.pack-list li:hover { background: rgba(0,0,0,0.3); cursor: pointer; }
    .pack-id { font-weight: 600; color: #4a9eff; }
    ul.puzzle-list { list-style: none; padding: 0; margin: 0.5rem 0; }
    ul.puzzle-list li {
      padding: 0.4rem 0.6rem;
      margin-bottom: 0.3rem;
      background: rgba(0,0,0,0.15);
      border-radius: 6px;
      font-size: 0.85rem;
    }
    small { color: #888; font-size: 0.85rem; }
    .hint { color: #888; font-size: 0.8rem; margin-top: -0.5rem; margin-bottom: 0.5rem; }
  </style>
</head>
<body>
  <nav class="side-nav">
    <h3>바로가기</h3>
    <a href="#packList">팩 목록 조회</a>
    <a href="#createPuzzle">문제 생성</a>
    <a href="#createPack">팩 생성</a>
  </nav>

  <div class="header">
    <div>
      <h1>Renzzle 어드민 - 팩/문제 관리</h1>
      <span class="user-info" th:if="${userEmail}" th:text="${userEmail}"></span>
    </div>
    <a href="/admin/logout" class="btn" id="logoutBtn">로그아웃</a>
  </div>

  <!-- 팩 목록 -->
  <section class="section" id="packList">
    <h2>팩 목록 (팩 선택 후 아래에서 문제 추가)</h2>
    <div class="row">
      <div>
        <label>난이도</label>
        <select id="filterDifficulty">
          <option value="LOW">LOW</option>
          <option value="MIDDLE">MIDDLE</option>
          <option value="HIGH">HIGH</option>
        </select>
      </div>
      <div>
        <label>언어</label>
        <select id="filterLang">
          <option value="EN">EN</option>
          <option value="KO">KO</option>
        </select>
      </div>
      <div style="display: flex; align-items: flex-end;">
        <button type="button" class="btn btn-primary" id="loadPacksBtn">목록 불러오기</button>
      </div>
    </div>
    <ul class="pack-list" id="packListUl"></ul>
    <div id="packListMsg" class="msg"></div>
  </section>

  <!-- 문제 생성 (AddTrainingPuzzleRequest 전체 필드) -->
  <section class="section" id="createPuzzle">
    <h2>문제 생성 (선택한 팩에 추가)</h2>
    <p class="hint">문제 DTO(AddTrainingPuzzleRequest)의 모든 항목을 입력하세요.</p>
    <label>팩 ID (packId) * <small>(목록에서 팩 클릭 시 자동 입력됨)</small></label>
    <input type="number" id="problemPackId" min="1" placeholder="위 목록에서 팩 클릭" required readonly style="background: rgba(0,0,0,0.3);">
    <div id="currentPuzzleList" style="display:none;">
      <label>현재 팩의 문제 목록 (순서대로)</label>
      <ul class="puzzle-list" id="puzzleListItems"></ul>
    </div>
    <label>문제 순서 (puzzleIndex) * <small>(비워두면 가장 마지막에 추가됨)</small></label>
    <input type="number" id="problemPuzzleIndex" min="1" placeholder="비워두면 마지막 순서로 자동 추가">
    
    <!-- 오목판 시각화 -->
    <div style="margin: 1.5rem 0;">
      <label>보드 상태 시각화</label>
      <p class="hint">오목판을 클릭해서 돌을 두거나, 아래 입력 칸에 직접 입력하세요.</p>
      <div style="display: flex; gap: 1rem; align-items: flex-start;">
        <canvas id="gomokuBoard" width="480" height="480" style="background: #DCB35C; border: 2px solid #333; cursor: default;"></canvas>
        <div style="flex: 1;">
          <button type="button" class="btn" id="clearBoardBtn" style="margin-bottom: 0.5rem;">보드 초기화</button>
          <button type="button" class="btn" id="undoMoveBtn" style="margin-bottom: 0.5rem;">마지막 수 취소</button>
          <p style="font-size: 0.85rem; color: #b0b0b0; margin: 0.5rem 0;">현재 차례: <span id="currentTurn" style="color: #fff; font-weight: 600;">흑</span></p>
        </div>
      </div>
    </div>
    
    <label>보드 상태 (boardStatus) *</label>
    <input type="text" id="problemBoardStatus" placeholder="예: h8i7i5h5... (15x15 보드 위치, a~o+숫자)" required>
    <p class="hint">형식: 행(a~o) + 열(1~15) 조합으로 돌 위치 나열. 예: h8i7i5h5 (오목판 클릭 시 자동 업데이트)</p>
    <label>정답 (answer) *</label>
    <input type="text" id="problemAnswer" placeholder="정답 문자열, 최대 1023자" maxlength="1023" required>
    <label>깊이 (depth) *</label>
    <input type="number" id="problemDepth" min="0" placeholder="숫자" required>
    <label>승리 색상 (winColor) *</label>
    <select id="problemWinColor">
      <option value="BLACK">BLACK</option>
      <option value="WHITE">WHITE</option>
    </select>
    <button type="button" class="btn btn-primary" id="createPuzzleBtn">문제 추가</button>
    <div id="createPuzzleMsg" class="msg"></div>
  </section>

  <!-- 팩 생성 (언어 최대 2개) -->
  <section class="section" id="createPack">
    <h2>팩 생성</h2>
    <p class="hint">언어별 설명은 최대 2개까지 등록 가능합니다. 1개만 작성해도 됩니다.</p>
    <div id="langBlocks">
      <div class="lang-block" data-lang-index="0">
        <h4>언어 1 (KO)</h4>
        <input type="hidden" name="langCode_0" value="KO">
        <label>언어 코드</label>
        <input type="text" value="KO" disabled style="background: rgba(0,0,0,0.3);">
        <label>제목 (title)</label>
        <input type="text" name="title_0" placeholder="팩 제목" required>
        <label>작성자 (author)</label>
        <input type="text" name="author_0" placeholder="작성자명" required>
        <label>설명 (description, 선택)</label>
        <textarea name="description_0" placeholder="팩 설명"></textarea>
      </div>
      <div class="lang-block" data-lang-index="1">
        <h4>언어 2 (EN, 선택)</h4>
        <input type="hidden" name="langCode_1" value="EN">
        <label>언어 코드</label>
        <input type="text" value="EN" disabled style="background: rgba(0,0,0,0.3);">
        <label>제목 (title)</label>
        <input type="text" name="title_1" placeholder="팩 제목">
        <label>작성자 (author)</label>
        <input type="text" name="author_1" placeholder="작성자명">
        <label>설명 (description, 선택)</label>
        <textarea name="description_1" placeholder="팩 설명"></textarea>
      </div>
    </div>
    <div class="row">
      <div>
        <label>가격 (price)</label>
        <input type="number" id="packPrice" min="0" value="0" required>
      </div>
      <div>
        <label>난이도 (difficulty)</label>
        <select id="packDifficulty">
          <option value="LOW">LOW</option>
          <option value="MIDDLE">MIDDLE</option>
          <option value="HIGH">HIGH</option>
        </select>
      </div>
    </div>
    <button type="button" class="btn btn-primary" id="createPackBtn">팩 생성</button>
    <div id="createPackMsg" class="msg"></div>
  </section>

  <script th:inline="javascript">
    const API_BASE = '';
    let isRefreshing = false;

    // ===== 오목판 관련 변수 및 함수 =====
    const canvas = document.getElementById('gomokuBoard');
    const ctx = canvas.getContext('2d');
    const BOARD_SIZE = 15;
    const CELL_SIZE = 30;
    const MARGIN = 30;  // 좌/상/우/하 동일 마진 (라벨용)
    const moves = [];   // [{row, col, player}] - row 0=하단(1행), row 14=상단(15행), col 0=a~14=o
    let currentPlayer = 'black';

    // 논리 좌표 -> 캔버스 좌표 (좌하 a1, 우상 o15)
    function toCanvasX(col) { return MARGIN + col * CELL_SIZE; }
    function toCanvasY(row) { return MARGIN + (14 - row) * CELL_SIZE; }

    function drawBoard() {
      ctx.fillStyle = '#DCB35C';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 1;
      
      for (let i = 0; i < BOARD_SIZE; i++) {
        const pos = MARGIN + i * CELL_SIZE;
        ctx.beginPath();
        ctx.moveTo(pos, MARGIN);
        ctx.lineTo(pos, MARGIN + (BOARD_SIZE - 1) * CELL_SIZE);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(MARGIN, pos);
        ctx.lineTo(MARGIN + (BOARD_SIZE - 1) * CELL_SIZE, pos);
        ctx.stroke();
      }
      
      // 화점 (star points) - 논리 좌표 row,col
      const starPoints = [
        [3, 3], [3, 11], [7, 7], [11, 3], [11, 11]
      ];
      starPoints.forEach(([row, col]) => {
        const x = toCanvasX(col);
        const y = toCanvasY(row);
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, Math.PI * 2);
        ctx.fill();
      });

      // 하단 마진: A ~ O (검은 글씨)
      ctx.fillStyle = '#000';
      ctx.font = '14px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      for (let c = 0; c < BOARD_SIZE; c++) {
        const x = toCanvasX(c);
        const y = canvas.height - MARGIN / 2;
        ctx.fillText(String.fromCharCode(65 + c), x, y);
      }

      // 좌측 마진: 1 ~ 15 하단부터 상단 (검은 글씨)
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      for (let r = 0; r < BOARD_SIZE; r++) {
        const y = toCanvasY(r);
        const x = MARGIN / 2;
        ctx.fillText(String(r + 1), x, y);
      }
    }

    function drawStone(row, col, player, moveNumber) {
      const x = toCanvasX(col);
      const y = toCanvasY(row);
      
      ctx.fillStyle = player === 'black' ? '#000' : '#fff';
      ctx.beginPath();
      ctx.arc(x, y, CELL_SIZE / 2 - 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = player === 'black' ? '#333' : '#999';
      ctx.lineWidth = 1;
      ctx.stroke();
      
      if (moveNumber) {
        ctx.fillStyle = player === 'black' ? '#fff' : '#000';
        ctx.font = 'bold 12px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(moveNumber, x, y);
      }
    }

    function redrawBoard() {
      drawBoard();
      moves.forEach((move, idx) => {
        drawStone(move.row, move.col, move.player, idx + 1);
      });
    }

    function boardStatusToMoves(boardStatus) {
      // "a1b2..." -> [{row, col, player}, ...] (a=col0, 1=row0/하단)
      const result = [];
      if (!boardStatus || boardStatus.trim() === '') return result;
      const regex = /([a-oA-O])(\d{1,2})/g;
      let match;
      let turnBlack = true;
      while ((match = regex.exec(boardStatus)) !== null) {
        const col = match[1].toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0);
        const row = parseInt(match[2], 10) - 1;  // 1~15 -> 0~14 (1=하단)
        if (row >= 0 && row < BOARD_SIZE && col >= 0 && col < BOARD_SIZE) {
          result.push({ row, col, player: turnBlack ? 'black' : 'white' });
          turnBlack = !turnBlack;
        }
      }
      return result;
    }

    function movesToBoardStatus(moves) {
      // row 0=1행(하단), col 0=a
      return moves.map(m => {
        const rowChar = String.fromCharCode('a'.charCodeAt(0) + m.col);
        const colNum = m.row + 1;
        return rowChar + colNum;
      }).join('');
    }

    function updateBoardStatusInput() {
      document.getElementById('problemBoardStatus').value = movesToBoardStatus(moves);
    }

    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      const col = Math.round((x - MARGIN) / CELL_SIZE);
      const row = 14 - Math.round((y - MARGIN) / CELL_SIZE);  // 캔버스 y 하->상 = 논리 row 0~14
      
      if (row < 0 || row >= BOARD_SIZE || col < 0 || col >= BOARD_SIZE) return;
      
      if (moves.some(m => m.row === row && m.col === col)) return;
      
      moves.push({ row, col, player: currentPlayer });
      redrawBoard();
      updateBoardStatusInput();
      
      currentPlayer = currentPlayer === 'black' ? 'white' : 'black';
      document.getElementById('currentTurn').textContent = currentPlayer === 'black' ? '흑' : '백';
    });

    document.getElementById('clearBoardBtn').addEventListener('click', () => {
      moves.length = 0;
      currentPlayer = 'black';
      document.getElementById('currentTurn').textContent = '흑';
      redrawBoard();
      updateBoardStatusInput();
    });

    document.getElementById('undoMoveBtn').addEventListener('click', () => {
      if (moves.length === 0) return;
      moves.pop();
      currentPlayer = currentPlayer === 'black' ? 'white' : 'black';
      document.getElementById('currentTurn').textContent = currentPlayer === 'black' ? '흑' : '백';
      redrawBoard();
      updateBoardStatusInput();
    });

    // boardStatus 입력 칸 변경 시 오목판에 반영
    document.getElementById('problemBoardStatus').addEventListener('input', (e) => {
      const newMoves = boardStatusToMoves(e.target.value);
      moves.length = 0;
      moves.push(...newMoves);
      currentPlayer = moves.length % 2 === 0 ? 'black' : 'white';
      document.getElementById('currentTurn').textContent = currentPlayer === 'black' ? '흑' : '백';
      redrawBoard();
    });

    // 초기 보드 그리기
    drawBoard();
    // ===== 오목판 관련 끝 =====

    function getCookie(name) {
      const value = `; ${document.cookie}`;
      const parts = value.split(`; ${name}=`);
      if (parts.length === 2) return parts.pop().split(';').shift();
      return null;
    }

    function getAuthHeaders() {
      const accessToken = getCookie('admin_accessToken');
      if (!accessToken) return null;
      return {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer ' + accessToken
      };
    }

    async function refreshAccessToken() {
      if (isRefreshing) return false;
      isRefreshing = true;
      try {
        const refreshToken = getCookie('admin_refreshToken');
        if (!refreshToken) return false;
        
        const res = await fetch(API_BASE + '/api/auth/reissueToken', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ refreshToken })
        });
        const data = await res.json();
        if (!data.isSuccess) return false;

        const { grantType, accessToken, refreshToken: newRefresh, accessTokenExpiredAt, refreshTokenExpiredAt } = data.response;
        document.cookie = `admin_accessToken=${accessToken}; path=/; max-age=${60 * 60}`;
        if (newRefresh) {
          document.cookie = `admin_refreshToken=${newRefresh}; path=/; max-age=${60 * 60 * 24 * 14}`;
        }
        return true;
      } catch (err) {
        return false;
      } finally {
        isRefreshing = false;
      }
    }

    async function fetchWithAuth(url, options = {}) {
      let headers = getAuthHeaders();
      if (!headers) {
        window.location.href = '/admin';
        throw new Error('로그인이 필요합니다.');
      }
      
      let res = await fetch(url, { ...options, headers });
      if (res.status === 401) {
        const refreshed = await refreshAccessToken();
        if (!refreshed) {
          window.location.href = '/admin';
          throw new Error('토큰 재발급 실패. 다시 로그인하세요.');
        }
        headers = getAuthHeaders();
        res = await fetch(url, { ...options, headers });
      }
      return res;
    }

    // ----- 팩 목록 -----
    document.getElementById('loadPacksBtn').addEventListener('click', async () => {
      const difficulty = document.getElementById('filterDifficulty').value;
      const lang = document.getElementById('filterLang').value;
      const msgEl = document.getElementById('packListMsg');
      const listEl = document.getElementById('packListUl');
      msgEl.classList.remove('show', 'success', 'error');
      listEl.innerHTML = '';

      try {
        const res = await fetchWithAuth(API_BASE + '/api/training/pack?difficulty=' + encodeURIComponent(difficulty) + '&lang=' + encodeURIComponent(lang));
        const data = await res.json();
        if (!data.isSuccess) {
          msgEl.textContent = data.errorResponse?.message || '목록 조회 실패';
          msgEl.classList.add('show', 'error');
          return;
        }
        const packs = (data.response || []).filter(p => p.title && p.title.trim() !== '');
        if (packs.length === 0) {
          listEl.innerHTML = '<li>해당 조건의 팩이 없습니다.</li>';
        } else {
          packs.forEach(p => {
            const li = document.createElement('li');
            li.innerHTML = '<span class="pack-id">ID: ' + p.id + '</span> ' + (p.title || '') + ' <small>가격:' + p.price + ' / 풀이:' + p.solvedPuzzleCount + '/' + p.totalPuzzleCount + '</small>';
            li.onclick = () => selectPack(p.id);
            listEl.appendChild(li);
          });
        }
        msgEl.textContent = packs.length + '개 조회됨';
        msgEl.classList.add('show', 'success');
      } catch (err) {
        msgEl.textContent = '오류: ' + (err.message || '');
        msgEl.classList.add('show', 'error');
      }
    });

    async function selectPack(packId) {
      document.getElementById('problemPackId').value = packId;
      document.getElementById('currentPuzzleList').style.display = 'block';
      const puzzleListEl = document.getElementById('puzzleListItems');
      puzzleListEl.innerHTML = '<li>로딩 중...</li>';

      document.getElementById('createPuzzle').scrollIntoView({ behavior: 'smooth', block: 'start' });

      try {
        const res = await fetchWithAuth(API_BASE + '/api/training/puzzle/' + packId);
        const data = await res.json();
        if (!data.isSuccess) {
          puzzleListEl.innerHTML = '<li>문제 목록 조회 실패</li>';
          return;
        }
        const puzzles = data.response || [];
        if (puzzles.length === 0) {
          puzzleListEl.innerHTML = '<li>문제가 없습니다. 첫 번째 문제를 추가하세요.</li>';
        } else {
          puzzleListEl.innerHTML = '';
          puzzles.forEach((pz, idx) => {
            const li = document.createElement('li');
            const boardShort = pz.boardStatus.length > 15 ? pz.boardStatus.substring(0, 15) + '...' : pz.boardStatus;
            li.textContent = (idx + 1) + '번: ID ' + pz.id + ' / depth ' + pz.depth + ' / ' + pz.winColor + (pz.isSolved ? ' (풀림)' : '');
            li.textContent += ' / 보드: ' + boardShort;
            puzzleListEl.appendChild(li);
          });
        }
      } catch (err) {
        puzzleListEl.innerHTML = '<li>오류: ' + (err.message || '') + '</li>';
      }
    }

    // ----- 팩 생성 (언어 최대 2개, 1개만 써도 됨) -----
    document.getElementById('createPackBtn').addEventListener('click', async () => {
      const msgEl = document.getElementById('createPackMsg');
      msgEl.classList.remove('show', 'success', 'error');

      const info = [];
      for (let i = 0; i < 2; i++) {
        const title = document.querySelector('input[name="title_' + i + '"]').value.trim();
        const author = document.querySelector('input[name="author_' + i + '"]').value.trim();
        if (!title || !author) continue;
        info.push({
          langCode: document.querySelector('input[name="langCode_' + i + '"]').value,
          title,
          author,
          description: document.querySelector('textarea[name="description_' + i + '"]').value.trim() || null
        });
      }
      if (info.length === 0) {
        msgEl.textContent = '언어 1개 이상으로 제목·작성자를 입력하세요.';
        msgEl.classList.add('show', 'error');
        return;
      }

      const price = parseInt(document.getElementById('packPrice').value, 10);
      const difficulty = document.getElementById('packDifficulty').value;

      try {
        const res = await fetchWithAuth(API_BASE + '/api/training/pack', {
          method: 'POST',
          body: JSON.stringify({ info, price, difficulty })
        });
        const data = await res.json();
        if (!data.isSuccess) {
          msgEl.textContent = data.errorResponse?.message || '팩 생성 실패';
          msgEl.classList.add('show', 'error');
          return;
        }
        const packId = data.response;
        msgEl.textContent = '팩 생성 완료. 팩 ID: ' + packId;
        msgEl.classList.add('show', 'success');
        
        // 입력값 초기화
        for (let i = 0; i < 2; i++) {
          document.querySelector('input[name="title_' + i + '"]').value = '';
          document.querySelector('input[name="author_' + i + '"]').value = '';
          document.querySelector('textarea[name="description_' + i + '"]').value = '';
        }
        document.getElementById('packPrice').value = 0;
        document.getElementById('packDifficulty').value = 'LOW';

        selectPack(packId);
        document.getElementById('loadPacksBtn').click();
      } catch (err) {
        msgEl.textContent = '오류: ' + (err.message || '');
        msgEl.classList.add('show', 'error');
      }
    });

    // ----- 문제 생성 (AddTrainingPuzzleRequest 전체) -----
    document.getElementById('createPuzzleBtn').addEventListener('click', async () => {
      const msgEl = document.getElementById('createPuzzleMsg');
      msgEl.classList.remove('show', 'success', 'error');

      const packId = parseInt(document.getElementById('problemPackId').value, 10);
      const puzzleIndexInput = document.getElementById('problemPuzzleIndex').value.trim();
      const puzzleIndex = puzzleIndexInput ? parseInt(puzzleIndexInput, 10) : 999999;
      const boardStatus = document.getElementById('problemBoardStatus').value.trim();
      const answer = document.getElementById('problemAnswer').value.trim();
      const depth = parseInt(document.getElementById('problemDepth').value, 10);
      const winColor = document.getElementById('problemWinColor').value;

      if (!packId || !boardStatus || !answer || isNaN(depth)) {
        msgEl.textContent = 'packId, boardStatus, answer, depth를 모두 입력하세요.';
        msgEl.classList.add('show', 'error');
        return;
      }

      try {
        const res = await fetchWithAuth(API_BASE + '/api/training/puzzle', {
          method: 'POST',
          body: JSON.stringify({ packId, puzzleIndex, boardStatus, answer, depth, winColor })
        });
        const data = await res.json();
        if (!data.isSuccess) {
          msgEl.textContent = data.errorResponse?.message || '문제 추가 실패';
          msgEl.classList.add('show', 'error');
          return;
        }
        const puzzleId = data.response;
        msgEl.textContent = '문제 추가 완료. 퍼즐 ID: ' + puzzleId + (puzzleIndexInput ? '' : ' (마지막 순서로 추가됨)');
        msgEl.classList.add('show', 'success');
        
        // 입력값 초기화
        document.getElementById('problemPuzzleIndex').value = '';
        document.getElementById('problemBoardStatus').value = '';
        document.getElementById('problemAnswer').value = '';
        document.getElementById('problemDepth').value = '';
        document.getElementById('problemWinColor').value = 'BLACK';

        selectPack(packId);
        document.getElementById('loadPacksBtn').click();
      } catch (err) {
        msgEl.textContent = '오류: ' + (err.message || '');
        msgEl.classList.add('show', 'error');
      }
    });
  </script>
</body>
</html>
